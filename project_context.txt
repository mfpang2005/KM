--- FILE: check_backend.py ---
import sys
import os
import importlib

# Add the current directory to sys.path to ensure we can import 'backend'
sys.path.append(os.getcwd())

print(f"Python Version: {sys.version}")
print(f"Executable: {sys.executable}")

def check_import(module_name):
    try:
        importlib.import_module(module_name)
        print(f"âœ… {module_name} found")
    except ImportError:
        print(f"âŒ {module_name} NOT FOUND")
    except Exception as e:
        print(f"âŒ {module_name} error: {e}")

print("\n--- Checking Dependencies ---")
check_import("fastapi")
check_import("uvicorn")
check_import("supabase")
check_import("dotenv")

print("\n--- Checking Project Modules ---")
try:
    from backend import database # type: ignore
    print("âœ… backend.database imported")
except ImportError as e:
    print(f"âŒ backend.database failed: {e}")

try:
    from backend import models # type: ignore
    print("âœ… backend.models imported")
except ImportError as e:
    print(f"âŒ backend.models failed: {e}")

try:
    from backend.routers import users # type: ignore
    print("âœ… backend.routers.users imported")
except ImportError as e:
    print(f"âŒ backend.routers.users failed: {e}")


--- FILE: check_users.py ---
import os
from dotenv import load_dotenv
from supabase import create_client, Client

load_dotenv("backend/.env")
url: str = os.environ.get("SUPABASE_URL")
key: str = os.environ.get("SUPABASE_KEY")

supabase: Client = create_client(url, key)

print("Fetching users from auth (requires service role key to work correctly for all users)...")
try:
    response = supabase.auth.admin.list_users()
    for user in response.users:
        print(f"ID: {user.id} | Email: {user.email} | Metadata: {user.user_metadata}")
except Exception as e:
    print(f"Error listing users (you might not be using service role key, using anon key): {e}")

    # Fallback: Query the public.users table just in case they are synced
    print("\nFallback: Fetching from public.users table")
    result = supabase.table("users").select("*").execute()
    for user in result.data:
        print(user)


--- FILE: check_users_frontend.py ---
import os
from supabase import create_client, Client

url: str = "https://wryhvvakeysdbktvemzo.supabase.co"
key: str = "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZSIsInJlZiI6IndyeWh2dmFrZXlzZGJrdHZlbXpvIiwicm9sZSI6ImFub24iLCJpYXQiOjE3NzE2MzY2NDAsImV4cCI6MjA4NzIxMjY0MH0.r4Io7xE4DuOzaHGQoJ21_d-pb_J5_JIDBDplvfKiGsY"

supabase: Client = create_client(url, key)

print("Fetching from public.users table in frontend Supabase instance...")
try:
    result = supabase.table("users").select("*").execute()
    for user in result.data:
        print(user)
except Exception as e:
    print(f"Error: {e}")


--- FILE: check_users_schema.py ---
import os
from dotenv import load_dotenv
from supabase import create_client, Client

load_dotenv("backend/.env")
url: str = os.environ.get("SUPABASE_URL")
key: str = os.environ.get("SUPABASE_KEY")

supabase: Client = create_client(url, key)

try:
    result = supabase.table("users").select("*").limit(1).execute()
    if result.data:
        print("Columns in public.users:")
        for k in result.data[0].keys():
            print(k)
    else:
        print("No users found to inspect schema.")
except Exception as e:
    print(f"Error: {e}")


--- FILE: push_context.py ---
import os
import google.generativeai as genai

# é…ç½®è¿‡æ»¤è§„åˆ™
EXCLUDE_DIRS = {'node_modules', 'venv', '.venv', '.git', '__pycache__', 'dist', 'build', '.next'}
EXCLUDE_FILES = {'.env'}
ALLOWED_EXTENSIONS = {'.py', '.jsx', '.js', '.sql'}

def scan_project_files(root_path: str) -> str:
    """é€’å½’æ‰«æå½“å‰ç›®å½•ä¸‹ç¬¦åˆæ¡ä»¶çš„æ–‡ä»¶å¹¶å°è£…æ ¼å¼"""
    context_text = ""
    for dirpath, dirnames, filenames in os.walk(root_path):
        # è¿‡æ»¤æ‰ä¸éœ€è¦æ‰«æçš„ç›®å½•
        dirnames[:] = [d for d in dirnames if d not in EXCLUDE_DIRS]
        
        for filename in filenames:
            # è¿‡æ»¤ä¸éœ€è¦çš„ç‰¹å®šæ–‡ä»¶
            if filename in EXCLUDE_FILES:
                continue
                
            # åªå¤„ç†æŒ‡å®šç±»å‹çš„æ–‡ä»¶
            ext = os.path.splitext(filename)[1].lower()
            if ext in ALLOWED_EXTENSIONS:
                filepath = os.path.join(dirpath, filename)
                # ä½¿ç”¨ç›¸å¯¹è·¯å¾„ä»¥ä¿æŒæ ¼å¼æ•´æ´
                rel_path = os.path.relpath(filepath, root_path)
                
                try:
                    with open(filepath, 'r', encoding='utf-8') as f:
                        content = f.read()
                    
                    # æŒ‰ç…§æŒ‡å®šçš„æ ¼å¼è¿›è¡Œå°è£…
                    context_text += f"--- FILE: {rel_path} ---\n{content}\n\n"
                except Exception as e:
                    print(f"æ— æ³•è¯»å–æ–‡ä»¶ {rel_path}: {e}")
                    
    return context_text

def main():
    # 1. è·å–å¯†é’¥
    api_key = os.getenv('GEMINI_API_KEY')
    if not api_key:
        print("é”™è¯¯ï¼šæœªæ‰¾åˆ°ç³»ç»Ÿç¯å¢ƒå˜é‡ GEMINI_API_KEYï¼Œè¯·å…ˆè®¾ç½®å¯†é’¥ã€‚")
        return
        
    print("æ­£åœ¨æ‰«æé¡¹ç›®æ–‡ä»¶å¹¶æ‰“åŒ…ä»£ç ä¸Šä¸‹æ–‡...")
    root_path = os.getcwd()
    
    # 2. æ‰«æå¹¶æ ¼å¼åŒ–æ–‡ä»¶
    project_context = scan_project_files(root_path)
    
    if not project_context:
        print("æœªæ‰«æåˆ°ç¬¦åˆæ¡ä»¶çš„ä»£ç æ–‡ä»¶ã€‚")
        return
        
    print(f"ä»£ç æ‰“åŒ…å®Œæˆï¼Œæ–‡æœ¬æ€»é•¿åº¦ {len(project_context)} å­—ç¬¦ã€‚")
    
    # å°†æ‰“åŒ…åçš„ä»£ç ä¿å­˜åˆ°æœ¬åœ°æ–‡ä»¶ï¼Œæ–¹ä¾¿ç”¨æˆ·åœ¨ AI Studio ç½‘é¡µç«¯ç›´æ¥ä¸Šä¼ æˆ–å¤åˆ¶
    output_file = "project_context.txt"
    try:
        with open(output_file, 'w', encoding='utf-8') as f:
            f.write(project_context)
        print(f"ä»£ç å·²ä¿å­˜åˆ°æœ¬åœ°æ–‡ä»¶ï¼š{output_file}")
        print("ğŸ’¡ æç¤ºï¼šAPI è°ƒç”¨çš„å¯¹è¯ä¸ä¼šæ˜¾ç¤ºåœ¨ AI Studio ç½‘é¡µç«¯ã€‚")
        print("ğŸ’¡ è¯·å‰å¾€ç½‘é¡µç«¯æ–°å»ºä¸€ä¸ª Promptï¼Œç„¶åå°† project_context.txt çš„å†…å®¹ç²˜è´´è¿›å»ï¼Œæˆ–è€…ç›´æ¥ä½œä¸ºæ–‡ä»¶é™„ä»¶ä¸Šä¼ ï¼")
    except Exception as e:
        print(f"ä¿å­˜æ–‡ä»¶å¤±è´¥ï¼š{e}")
        
    print("æ­£åœ¨è¿æ¥å¹¶æ¨é€æµ‹è¯•è¯·æ±‚è‡³ Google API...")
    
    try:
        # 3. åˆå§‹åŒ– Gemini API
        genai.configure(api_key=api_key)
        
        # 4. åˆ›å»º GenerativeModel å®ä¾‹
        # æˆ‘ä»¬ä½¿ç”¨ gemini-2.5-flash é¿å…å…è´¹ç‰ˆé¢åº¦é™åˆ¶
        # å¹¶å°†ä¸Šä¸‹æ–‡å†…å®¹åˆ©ç”¨ system_instruction ä¼ å…¥
        model = genai.GenerativeModel(
            model_name="gemini-2.5-flash",
            system_instruction=(
                "ä½ æ˜¯ä¸€ä¸ªé«˜çº§ä»£ç åŠ©æ‰‹ã€‚ä»¥ä¸‹æ˜¯å½“å‰é¡¹ç›®çš„ä»£ç ä¸Šä¸‹æ–‡ï¼Œè¯·ä½ ä»”ç»†é˜…è¯»å¹¶ç†è§£å…¶æ¶æ„å’Œé€»è¾‘ã€‚"
                "åœ¨æœªæ¥çš„å›ç­”ä¸­ï¼Œè¯·å§‹ç»ˆç»“åˆæ­¤ä¸Šä¸‹æ–‡çš„å†…å®¹è¿›è¡Œå›å¤ã€‚\n\n"
                f"{project_context}"
            )
        )
        
        # 5. å¼€å¯å¯¹è¯ä¼šè¯ (Chat Session)
        chat = model.start_chat()
        
        # 6. å‘é€åˆå§‹æ¶ˆæ¯å»ºç«‹ä¼šè¯å¹¶ç¡®è®¤è§£æ
        response = chat.send_message("æˆ‘å·²ç»æä¾›äº†é¡¹ç›®çš„ä¸Šä¸‹æ–‡ä¿¡æ¯ï¼Œè¯·ç®€çŸ­ç¡®è®¤ä½ å·²æ¥æ”¶å‡†å¤‡å°±ç»ªã€‚")
        
        # 7. æ‰“å°æç¤ºä¿¡æ¯
        print("ã€é¡¹ç›®ä¸Šä¸‹æ–‡å·²æ¨é€è‡³ Google AIï¼Œä½ ç°åœ¨å¯ä»¥å‰å¾€ AI Studio é’ˆå¯¹å…·ä½“é€»è¾‘æé—®ã€‚ã€")
        
    except Exception as e:
        print(f"æ¨é€è¿‡ç¨‹ä¸­å‘ç”Ÿé”™è¯¯ï¼š{e}")

if __name__ == "__main__":
    main()


--- FILE: setup_storage.py ---
"""
åˆå§‹åŒ– Supabase Storage Bucket è„šæœ¬
è¿è¡Œæ–¹æ³•ï¼špython setup_storage.py

å‰ç½®æ¡ä»¶ï¼š
- åœ¨ Supabase æ§åˆ¶å° â†’ é¡¹ç›® Settings â†’ API ä¸­æ‰¾åˆ° service_role key
- å°†è¯¥ key æ›¿æ¢åˆ°ä¸‹æ–¹ SERVICE_ROLE_KEY å˜é‡
"""
import os
import httpx

SUPABASE_URL = "https://wryhvvakeysdbktvemzo.supabase.co"

# åœ¨ Supabase æ§åˆ¶å° â†’ Settings â†’ API â†’ service_role (secret) ä¸­å¤åˆ¶
SERVICE_ROLE_KEY = os.getenv("SUPABASE_SERVICE_ROLE_KEY", "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZSIsInJlZiI6IndyeWh2dmFrZXlzZGJrdHZlbXpvIiwicm9sZSI6InNlcnZpY2Vfcm9sZSIsImlhdCI6MTc3MTYzNjY0MCwiZXhwIjoyMDg3MjEyNjQwfQ.jSX6PhPX1do1QOJl3bQVJ2tYrS5xDrL0TDF6EsAuUbc")

HEADERS = {
    "apikey": SERVICE_ROLE_KEY,
    "Authorization": f"Bearer {SERVICE_ROLE_KEY}",
    "Content-Type": "application/json",
}


def create_bucket():
    """åˆ›å»º delivery-photos Public Bucket"""
    url = f"{SUPABASE_URL}/storage/v1/bucket"
    payload = {
        "id": "delivery-photos",
        "name": "delivery-photos",
        "public": True,  # å…¬å¼€ bucketï¼Œç®¡ç†å‘˜å¯ç›´æ¥é€šè¿‡ URL æŸ¥çœ‹ç…§ç‰‡
        "file_size_limit": 10485760,  # 10 MB å•æ–‡ä»¶ä¸Šä¼ é™åˆ¶
        "allowed_mime_types": ["image/jpeg", "image/png", "image/webp", "image/heic"],
    }

    response = httpx.post(url, json=payload, headers=HEADERS)

    if response.status_code == 200:
        print("âœ… Bucket 'delivery-photos' åˆ›å»ºæˆåŠŸï¼ˆPublicï¼‰")
    elif response.status_code == 409:
        print("â„¹ï¸  Bucket 'delivery-photos' å·²å­˜åœ¨ï¼Œè·³è¿‡åˆ›å»º")
    else:
        print(f"âŒ åˆ›å»º Bucket å¤±è´¥: {response.status_code} - {response.text}")
        return False
    return True


def create_upload_policy():
    """é€šè¿‡ REST API æ·»åŠ  Storage Policyï¼Œå…è®¸å·²è®¤è¯ç”¨æˆ·ä¸Šä¼ """
    # ä½¿ç”¨ Supabase SQL æ¥å£æ‰§è¡Œ RLS Policy
    url = f"{SUPABASE_URL}/rest/v1/rpc"

    policy_sql = """
    -- å·²è®¤è¯ç”¨æˆ·å¯ä¸Šä¼ åˆ° delivery-photos bucket
    CREATE POLICY IF NOT EXISTS "Allow authenticated uploads"
    ON storage.objects FOR INSERT
    TO authenticated
    WITH CHECK (bucket_id = 'delivery-photos');

    -- æ‰€æœ‰äººå¯è¯»ï¼ˆå› ä¸ºæ˜¯ public bucketï¼‰
    CREATE POLICY IF NOT EXISTS "Allow public read"
    ON storage.objects FOR SELECT
    TO public
    USING (bucket_id = 'delivery-photos');
    """

    sql_url = f"{SUPABASE_URL}/rest/v1/sql"
    response = httpx.post(sql_url, json={"query": policy_sql}, headers=HEADERS)

    if response.status_code in [200, 201]:
        print("âœ… Storage Policy é…ç½®æˆåŠŸï¼ˆauthenticated å¯ä¸Šä¼ ï¼Œpublic å¯è¯»ï¼‰")
    else:
        # æ³¨æ„ï¼šéƒ¨åˆ† Supabase ç‰ˆæœ¬ä¸æ”¯æŒç›´æ¥ SQLï¼Œè¿™é‡Œç»™å‡ºæ‰‹åŠ¨æ“ä½œæç¤º
        print(f"âš ï¸  Policy è‡ªåŠ¨é…ç½®å¤±è´¥ï¼ˆ{response.status_code}ï¼‰ï¼Œè¯·æ‰‹åŠ¨åœ¨æ§åˆ¶å°æ·»åŠ ï¼š")
        print("   Supabase Dashboard â†’ Storage â†’ delivery-photos â†’ Policies")
        print("   æ·»åŠ  INSERT Policy for 'authenticated' role")


if __name__ == "__main__":
    print("ğŸš€ å¼€å§‹åˆå§‹åŒ– Supabase Storage...\n")

    if SERVICE_ROLE_KEY == "YOUR_SERVICE_ROLE_KEY_HERE":
        print("âŒ è¯·å…ˆè®¾ç½® SERVICE_ROLE_KEYï¼")
        print()
        print("è·å–æ–¹å¼ï¼š")
        print("  Supabase æ§åˆ¶å° â†’ Settings â†’ API â†’ service_role (secret key)")
        print()
        print("è®¾ç½®æ–¹å¼ï¼ˆä»»é€‰ä¸€ï¼‰ï¼š")
        print("  1. è®¾ç½®ç¯å¢ƒå˜é‡ï¼šset SUPABASE_SERVICE_ROLE_KEY=<your_key>")
        print("  2. ç›´æ¥ä¿®æ”¹è„šæœ¬ç¬¬ 16 è¡Œçš„ SERVICE_ROLE_KEY å˜é‡")
        exit(1)

    success = create_bucket()
    if success:
        create_upload_policy()

    print("\nâœ… åˆå§‹åŒ–å®Œæˆï¼ç°åœ¨å¸æœºå¯ä»¥ä¸Šä¼ ç…§ç‰‡ï¼Œç®¡ç†å‘˜å¯ä»¥åŠ è½½æŸ¥é˜…äº†ã€‚")


--- FILE: admin-web\eslint.config.js ---
import js from '@eslint/js'
import globals from 'globals'
import reactHooks from 'eslint-plugin-react-hooks'
import reactRefresh from 'eslint-plugin-react-refresh'
import tseslint from 'typescript-eslint'
import { defineConfig, globalIgnores } from 'eslint/config'

export default defineConfig([
  globalIgnores(['dist']),
  {
    files: ['**/*.{ts,tsx}'],
    extends: [
      js.configs.recommended,
      tseslint.configs.recommended,
      reactHooks.configs.flat.recommended,
      reactRefresh.configs.vite,
    ],
    languageOptions: {
      ecmaVersion: 2020,
      globals: globals.browser,
    },
  },
])


--- FILE: admin-web\postcss.config.js ---
export default {
    plugins: {
        tailwindcss: {},
        autoprefixer: {},
    },
}


--- FILE: admin-web\tailwind.config.js ---
/** @type {import('tailwindcss').Config} */
export default {
    content: [
        "./index.html",
        "./src/**/*.{js,ts,jsx,tsx}",
    ],
    theme: {
        extend: {
            colors: {
                primary: '#1A365D', // Deep blue example
            }
        },
    },
    plugins: [],
}


--- FILE: backend\database.py ---
import os
from supabase import create_client, Client
from dotenv import load_dotenv

load_dotenv()

# è·å– Supabase é…ç½®
url = os.getenv("SUPABASE_URL")
key = os.getenv("SUPABASE_KEY")

if not url or not key:
    raise ValueError("SUPABASE_URL and SUPABASE_KEY must be set in .env file")

# åˆ›å»º Supabase å®¢æˆ·ç«¯
supabase: Client = create_client(url, key)


--- FILE: backend\force_admin.py ---
import os
import requests
from dotenv import load_dotenv

env_path = os.path.join(os.path.dirname(__file__), '..', '.env.local')
load_dotenv(env_path)

url = os.environ.get("VITE_SUPABASE_URL") or os.environ.get("SUPABASE_URL")
key = os.environ.get("SUPABASE_SERVICE_ROLE_KEY") # éœ€è¦æœåŠ¡è§’è‰²æƒé™æ¥ç»•è¿‡ Rate Limit

# å¦‚æœæ²¡æœ‰é…ç½® Service Role Keyï¼Œæˆ‘ä»¬æ— æ³•ç›´æ¥ç”¨ Python SDK è°ƒç”¨ auth_adminï¼Œ
# è€Œæ˜¯è°ƒç”¨ REST API å‘ auth æ¥å£å‘è¯·æ±‚ã€‚ç”šè‡³é€€ä¸€æ­¥ï¼šå³ä½¿æ˜¯ Anon Key ä¹Ÿä¼šè¢«æ‹¦æˆªã€‚

# ä½†æ˜¯æˆ‘ä»¬å¯ä»¥é€šè¿‡æ™®é€šç”¨æˆ·åˆ›å»ºçš„æ¥å£å…ˆå°è¯•åˆ©ç”¨ postgres ç›´æ¥å¯¹ auth.users è¿›è¡Œæ“ä½œå—ï¼Ÿ
# ä¸è¡Œï¼ŒREST postgrest ä¸å…è®¸ç›´æ¥å†™ auth.usersï¼Œåªèƒ½èµ° auth_adminã€‚
# ä½†æ˜¯æˆ‘æ³¨æ„åˆ°ç”¨æˆ·ç¯å¢ƒå˜é‡ä¸­ä¹Ÿè®¸å¹¶æ²¡æœ‰ SUPABASE_SERVICE_ROLE_KEY è¿™ä¸ªå€¼ï¼
# å¦‚æœæ²¡æœ‰ Service Keyï¼Œé‚£ä»£ç ä¹Ÿæ˜¯æ²¡æƒé™ä¿®æ”¹ auth.users çš„ã€‚

# Let me check if the user has Service Role key in backend/.env:


--- FILE: backend\main.py ---
from fastapi import FastAPI
from fastapi.middleware.cors import CORSMiddleware
from routers import super_admin
from routers import walkie_talkie
from routers import admin_users
from routers import orders
from routers import products
from routers import users

app = FastAPI(title="Kim Long Smart Catering System API")

# NOTE: é…ç½® CORSï¼Œå…è®¸å‰ç«¯å¼€å‘æœåŠ¡å™¨çš„æ‰€æœ‰å¯èƒ½ç«¯å£
origins = [
    "http://localhost:5173",
    "http://localhost:5174",
    "http://localhost:3000",
    "http://localhost:3001",
]

app.add_middleware(
    CORSMiddleware,
    allow_origins=origins,
    allow_credentials=True,
    allow_methods=["*"],
    allow_headers=["*"],
)

app.include_router(orders.router)
app.include_router(products.router)
app.include_router(users.router)
app.include_router(admin_users.router)
app.include_router(super_admin.router)
app.include_router(walkie_talkie.router)


@app.get("/")
async def root():
    return {"message": "Welcome to Kim Long Smart Catering System API"}


--- FILE: backend\models.py ---
from typing import List, Optional
from enum import Enum
from pydantic import BaseModel
from datetime import datetime


class UserRole(str, Enum):
    ADMIN = 'admin'
    KITCHEN = 'kitchen'
    DRIVER = 'driver'
    SUPER_ADMIN = 'super_admin'


class UserStatus(str, Enum):
    PENDING = 'pending'
    ACTIVE = 'active'
    DELETED = 'deleted'


class OrderStatus(str, Enum):
    PENDING = 'pending'
    PREPARING = 'preparing'
    READY = 'ready'
    DELIVERING = 'delivering'
    COMPLETED = 'completed'


class PaymentMethod(str, Enum):
    CASH = 'cash'
    BANK_TRANSFER = 'bank_transfer'
    EWALLET = 'ewallet'
    CHEQUE = 'cheque'


class OrderItem(BaseModel):
    id: str
    name: str
    quantity: int
    note: Optional[str] = None
    price: Optional[float] = 0.0


class OrderBase(BaseModel):
    customerName: str
    customerPhone: str
    address: str
    items: List[OrderItem]
    status: OrderStatus
    dueTime: str
    amount: float
    type: str  # 'dine-in' | 'takeaway' | 'delivery'
    batch: Optional[str] = None
    driverId: Optional[str] = None
    paymentMethod: Optional[PaymentMethod] = None
    paymentStatus: Optional[str] = 'pending'
    delivery_photos: Optional[List[str]] = []


class OrderCreate(OrderBase):
    pass


class OrderUpdate(BaseModel):
    customerName: Optional[str] = None
    customerPhone: Optional[str] = None
    address: Optional[str] = None
    status: Optional[OrderStatus] = None
    dueTime: Optional[str] = None
    amount: Optional[float] = None
    type: Optional[str] = None
    batch: Optional[str] = None
    driverId: Optional[str] = None
    paymentMethod: Optional[PaymentMethod] = None
    paymentStatus: Optional[str] = None


class Order(OrderBase):
    id: str
    created_at: Optional[datetime] = None


class Product(BaseModel):
    id: str
    code: str
    name: str
    price: float
    category: Optional[str] = None
    image_url: Optional[str] = None


class User(BaseModel):
    id: str
    email: str
    role: UserRole
    status: Optional[UserStatus] = UserStatus.PENDING
    name: Optional[str] = None
    phone: Optional[str] = None
    avatar_url: Optional[str] = None
    vehicle_model: Optional[str] = None
    vehicle_plate: Optional[str] = None
    vehicle_type: Optional[str] = None
    vehicle_status: Optional[str] = 'idle'


# â”€â”€ Super Admin ä¸“ç”¨æ¨¡å‹ â”€â”€


class UserUpdate(BaseModel):
    """
    Super Admin ä¿®æ”¹ç”¨æˆ·ä¿¡æ¯æ—¶ä½¿ç”¨çš„è¯·æ±‚ä½“
    """
    role: Optional[UserRole] = None
    status: Optional[UserStatus] = None
    name: Optional[str] = None
    phone: Optional[str] = None
    is_disabled: Optional[bool] = None
    vehicle_model: Optional[str] = None
    vehicle_plate: Optional[str] = None
    vehicle_type: Optional[str] = None
    vehicle_status: Optional[str] = None


class SystemConfig(BaseModel):
    """
    ç³»ç»Ÿé…ç½®é”®å€¼å¯¹
    """
    key: str
    value: dict
    updated_at: Optional[datetime] = None
    updated_by: Optional[str] = None


class SystemConfigUpdate(BaseModel):
    """
    æ›´æ–°ç³»ç»Ÿé…ç½®çš„è¯·æ±‚ä½“
    """
    value: dict


class AuditLog(BaseModel):
    """
    å®¡è®¡æ—¥å¿—è®°å½•
    """
    id: Optional[str] = None
    actor_id: str
    actor_role: str
    action: str
    target: Optional[str] = None
    detail: Optional[dict] = None
    created_at: Optional[datetime] = None


class StatsOverview(BaseModel):
    """
    Super Admin ç»Ÿè®¡æ€»è§ˆ
    """
    total_orders: int
    total_revenue: float
    total_users: int
    orders_by_status: dict
    recent_orders: List[Order] = []


--- FILE: backend\schema.sql ---
-- Enable UUID extension
create extension if not exists "uuid-ossp";

-- Create orders table
create table orders (
  id text primary key, -- Keeping as text to match frontend 'KL-xxxx' format, or use uuid
  "customerName" text not null,
  "customerPhone" text,
  address text,
  items jsonb, -- Storing items as JSONB for simplicity as discussed
  status text check (status in ('pending', 'preparing', 'ready', 'delivering', 'completed')),
  amount numeric,
  "dueTime" text,
  type text,
  "driverId" text,
  "paymentMethod" text,
  "paymentStatus" text,
  created_at timestamp with time zone default timezone('utc'::text, now())
);

-- Create products table
create table products (
  id text primary key,
  code text unique,
  name text,
  price numeric,
  category text,
  image_url text
);

-- Row Level Security (RLS) - Optional for initial dev but good practice
alter table orders enable row level security;
alter table products enable row level security;

-- Create policies (allowing public access for now for simplicity of testing)
create policy "Public orders access" on orders for all using (true);
create policy "Public products access" on products for all using (true);

-- Create users table
create table users (
  id uuid default uuid_generate_v4() primary key,
  email text unique not null,
  role text check (role in ('admin', 'kitchen', 'driver')),
  name text,
  phone text,
  avatar_url text
);

create policy "Public users access" on users for all using (true);


--- FILE: backend\test_api.py ---
import httpx
import asyncio
from dotenv import load_dotenv
import os

# 1. è‡ªåŠ¨åŠ è½½ç¯å¢ƒå˜é‡
load_dotenv()

BASE_URL = "http://127.0.0.1:8000"  # ç¡®ä¿ä½ çš„ FastAPI å·²ç»å¯åŠ¨

async def test_backend_flow():
    print("Starting backend dependency test...")
    
    async with httpx.AsyncClient(base_url=BASE_URL, timeout=10.0) as client:
        try:
            # Test 1: Health Check
            print("--- Test 1: Endpoint Connectivity ---")
            response = await client.get("/")
            print(f"Status: {response.status_code}, Response: {response.json()}")
            
            # Test 2: Business logic test
            print("\n--- Test 2: Business Interface Test ---")
            biz_response = await client.get("/api/v1/status")
            if biz_response.status_code == 200:
                print("OK: Business interface active")
            else:
                print(f"Warning: Business interface status: {biz_response.status_code}")

        except httpx.ConnectError:
            print("\nError: Could not connect to server. Please ensure 'uvicorn main:app --reload' is running.")
        except Exception as e:
            print(f"\nError: Unexpected error occurred: {e}")

if __name__ == "__main__":
    # è¿è¡Œå¼‚æ­¥æµ‹è¯•
    asyncio.run(test_backend_flow())


--- FILE: backend\__init__.py ---


--- FILE: backend\middleware\auth.py ---
"""
è®¤è¯ä¸æƒé™å®ˆå«ä¸­é—´ä»¶
é€šè¿‡ Supabase JWT éªŒè¯ç”¨æˆ·èº«ä»½ï¼Œå¹¶æä¾›åŸºäºè§’è‰²çš„è®¿é—®æ§åˆ¶
"""
import os
import logging
from typing import Optional

from fastapi import Depends, HTTPException, Header
from database import supabase
from models import UserRole

logger = logging.getLogger(__name__)


async def get_current_user(authorization: Optional[str] = Header(None)) -> dict:
    """
    ä» Authorization è¯·æ±‚å¤´ä¸­è§£æ Supabase JWT Tokenï¼Œ
    è¿”å›å½“å‰ç”¨æˆ·çš„ id å’Œ roleã€‚

    NOTE: åŒæ—¶æ”¯æŒä¸¤ç§è®¤è¯æ–¹å¼ï¼š
    1. Supabase Auth JWTï¼ˆæ ‡å‡†æ–¹å¼ï¼‰
    2. ç®€æ˜“ Header æ–¹å¼ â€”â€” ä¼ é€’ x-user-id + x-user-roleï¼ˆå¼€å‘/æµ‹è¯•ç”¨ï¼‰
    """
    if authorization and authorization.startswith("Bearer "):
        token = authorization.replace("Bearer ", "")
        try:
            # NOTE: ä½¿ç”¨ Supabase auth.get_user éªŒè¯ token çš„æœ‰æ•ˆæ€§
            user_response = supabase.auth.get_user(token)
            if not user_response or not user_response.user:
                raise HTTPException(status_code=401, detail="Invalid or expired token")

            user_id = user_response.user.id
            user_metadata = user_response.user.user_metadata or {}
            role = user_metadata.get("role", "admin")

            return {"id": str(user_id), "role": role}
        except HTTPException:
            raise
        except Exception as e:
            logger.error("Token verification failed: %s", str(e))
            raise HTTPException(status_code=401, detail="Token verification failed")

    raise HTTPException(
        status_code=401,
        detail="Missing or invalid Authorization header. Expected: Bearer <token>"
    )


async def require_admin(
    current_user: dict = Depends(get_current_user),
) -> dict:
    """
    æƒé™å®ˆå«ï¼šå…è®¸ admin æˆ– super_admin è®¿é—®ã€‚ï¼ˆé€‚ç”¨äºå¸¸è§„åå°æ“ä½œï¼‰
    """
    if current_user.get("role") not in [UserRole.ADMIN.value, UserRole.SUPER_ADMIN.value]:
        logger.warning(
            "Unauthorized admin access attempt by user %s (role: %s)",
            current_user.get("id"),
            current_user.get("role"),
        )
        raise HTTPException(
            status_code=403,
            detail="Insufficient permissions. Admin access required."
        )
    return current_user


async def require_super_admin(
    current_user: dict = Depends(get_current_user),
) -> dict:
    """
    æƒé™å®ˆå«ï¼šä»…å…è®¸ super_admin è§’è‰²è®¿é—®ã€‚ï¼ˆé€‚ç”¨äºæœ€é«˜å±‚çº§æ•æ„Ÿææƒæ§åˆ¶ï¼‰
    ä½œä¸º FastAPI è·¯ç”±çš„ä¾èµ–é¡¹æ³¨å…¥ä½¿ç”¨ã€‚
    """
    if current_user.get("role") != UserRole.SUPER_ADMIN.value:
        logger.warning(
            "Unauthorized super_admin access attempt by user %s (role: %s)",
            current_user.get("id"),
            current_user.get("role"),
        )
        raise HTTPException(
            status_code=403,
            detail="Insufficient permissions. Super Admin access required."
        )
    return current_user


--- FILE: backend\middleware\__init__.py ---


--- FILE: backend\routers\admin_users.py ---
from fastapi import APIRouter, HTTPException, Depends
from typing import List
from database import supabase
from models import User, UserRole, UserStatus, UserUpdate
from middleware.auth import require_admin
import logging

logger = logging.getLogger(__name__)

router = APIRouter(
    prefix="/admin/users",
    tags=["admin-users"],
    dependencies=[Depends(require_admin)]
)

@router.post("/", response_model=User)
async def create_internal_user(
    email: str,
    role: UserRole,
    name: str = None,
    current_user: dict = Depends(require_admin)
):
    """
    ç®¡ç†å‘˜æ‰‹åŠ¨ä¸‹å‘å†…éƒ¨è´¦å· (å¦‚ Kitchen, Driver)
    å°†ç›´æ¥æ³¨å†Œå¹¶é»˜è®¤ä¸º ACTIVE çŠ¶æ€
    æ³¨æ„ï¼šåœ¨å®é™…ç¯å¢ƒä¸­è¿™é‡Œåº”è¯¥è°ƒç”¨ supabase.auth.admin.create_user å‘é…å¯†ç 
    """
    try:
        data = {
            "email": email,
            "role": role.value,
            "name": name,
            "status": UserStatus.ACTIVE.value
        }
        # ç”±äºæˆ‘ä»¬å°šæœªå®Œå…¨æ¥å…¥åç«¯å‘ä¿¡Authï¼Œæˆ‘ä»¬åªå†™ä¸šåŠ¡è¡¨
        response = supabase.table("users").insert(data).execute()
        
        # è®°å½•å®¡è®¡æ—¥å¿—
        supabase.table("audit_logs").insert({
            "actor_id": current_user.get("id"),
            "actor_role": current_user.get("role"),
            "action": "create_internal_user",
            "target": email,
            "detail": {"role": role.value, "status": UserStatus.ACTIVE.value}
        }).execute()
        
        return response.data[0]
    except Exception as e:
        logger.error(f"Failed to create user: {e}")
        raise HTTPException(status_code=500, detail="Failed to create user account")


@router.patch("/{user_id}/status", response_model=User)
async def update_user_status(
    user_id: str,
    status: UserStatus,
    current_user: dict = Depends(require_admin)
):
    """
    å·¥ä½œæµï¼šå®¡æ‰¹å¤–éƒ¨è´¦å· (PENDING -> ACTIVE) 
    æˆ–è½¯åˆ é™¤è´¦å· (-> DELETED) 
    æˆ–å°åœè´¦å· (-> DELETED/PENDING)
    """
    # ä¸èƒ½å°åœè‡ªå·±
    if user_id == current_user.get("id"):
        raise HTTPException(status_code=400, detail="Cannot alter your own status")
    
    response = supabase.table("users").update({"status": status.value}).eq("id", user_id).execute()
    if not response.data:
        raise HTTPException(status_code=404, detail="User not found")
        
    # è®°å½•å®¡è®¡æ—¥å¿—
    supabase.table("audit_logs").insert({
        "actor_id": current_user.get("id"),
        "actor_role": current_user.get("role"),
        "action": f"change_user_status_to_{status.value}",
        "target": user_id
    }).execute()
    
    return response.data[0]


--- FILE: backend\routers\orders.py ---
from fastapi import APIRouter, HTTPException, Depends
from typing import List
from database import supabase
from models import Order, OrderCreate, OrderUpdate, OrderStatus

router = APIRouter(
    prefix="/orders",
    tags=["orders"]
)

@router.get("", response_model=List[Order])
async def get_orders():
    # In a real app, we would join with order_items table. 
    # For now, assuming 'items' is stored as a JSONB column or similar for simplicity, 
    # OR we fetch items separately. 
    # Let's assume a flat structure for now or that Supabase returns the joined data if configured.
    # To keep it simple and aligned with the "no SQL" requirement from the prompt (it said "use Supabase"),
    # we'll use the JS/Python client which returns JSON.
    
    response = supabase.table("orders").select("*").execute()
    return response.data

@router.get("/{order_id}", response_model=Order)
async def get_order(order_id: str):
    response = supabase.table("orders").select("*").eq("id", order_id).execute()
    if not response.data:
        raise HTTPException(status_code=404, detail="Order not found")
    return response.data[0]

@router.post("", response_model=Order)
async def create_order(order: OrderCreate):
    # Depending on how we structure the DB, we might need to insert into 'orders' and 'order_items'
    # For this POC, let's assume 'items' is a JSONB column in 'orders' table to save time and complexity,
    # or we handle the relation insert.
    # Let's try to insert the whole object. Supabase handles JSONB well.
    
    order_data = order.dict()
    # If 'items' is a relation, we need to pop it and insert separately. 
    # For simplicity in this iteration, I'll assume we can store it as JSONB in the 'orders' table 
    # OR I'll assume the frontend sends what the DB expects.
    # Let's go with JSONB for 'items' for now to speed up development unless strict relational schema is required.
    # However, standard practice is normalized.
    # Let's assume the DB has an 'items' jsonb column for now to match the frontend 'items' array.
    
    response = supabase.table("orders").insert(order_data).execute()
    if not response.data:
         raise HTTPException(status_code=400, detail="Could not create order")
    return response.data[0]

@router.put("/{order_id}", response_model=Order)
async def update_order(order_id: str, order: OrderCreate):
    response = supabase.table("orders").update(order.dict()).eq("id", order_id).execute()
    if not response.data:
        raise HTTPException(status_code=404, detail="Order not found or update failed")
    return response.data[0]

@router.post("/{order_id}/status", response_model=Order)
async def update_order_status(order_id: str, status: OrderStatus):
    response = supabase.table("orders").update({"status": status}).eq("id", order_id).execute()
    if not response.data:
        raise HTTPException(status_code=404, detail="Order not found")
    return response.data[0]

@router.patch("/{order_id}", response_model=Order)
async def partial_update_order(order_id: str, update: OrderUpdate):
    update_data = {k: v for k, v in update.model_dump().items() if v is not None}
    if not update_data:
        raise HTTPException(status_code=400, detail="No fields to update")
        
    # Handle Enum to string conversion if needed
    if "status" in update_data:
        update_data["status"] = update_data["status"].value if hasattr(update_data["status"], "value") else update_data["status"]
    if "paymentMethod" in update_data:
        update_data["paymentMethod"] = update_data["paymentMethod"].value if hasattr(update_data["paymentMethod"], "value") else update_data["paymentMethod"]

    response = supabase.table("orders").update(update_data).eq("id", order_id).execute()
    if not response.data:
        raise HTTPException(status_code=404, detail="Order not found or update failed")
    return response.data[0]

@router.delete("/{order_id}")
async def delete_order(order_id: str):
    response = supabase.table("orders").delete().eq("id", order_id).execute()
    return {"message": "Order deleted"}


# NOTE: å¸æœºå®Œæˆé€é¤åå°†ç…§ç‰‡ URL åˆ—è¡¨å†™å…¥å¯¹åº”è®¢å•ï¼Œä¾› Admin å®¡é˜…
@router.patch("/{order_id}/photos")
async def update_delivery_photos(order_id: str, photos: dict):
    """
    æ¥æ”¶ { "delivery_photos": [url1, url2, ...] } å¹¶æ›´æ–°è‡³å¯¹åº”è®¢å•
    """
    photo_urls = photos.get("delivery_photos", [])
    if not photo_urls:
        raise HTTPException(status_code=400, detail="No photos provided")
    response = (
        supabase.table("orders")
        .update({"delivery_photos": photo_urls})
        .eq("id", order_id)
        .execute()
    )
    if not response.data:
        raise HTTPException(status_code=404, detail="Order not found")
    return response.data[0]


--- FILE: backend\routers\products.py ---
from fastapi import APIRouter, File, UploadFile
from typing import List, Optional
from database import supabase
from models import Product
from pydantic import BaseModel
import uuid

router = APIRouter(
    prefix="/products",
    tags=["products"]
)


class ProductCreate(BaseModel):
    """
    NOTE: åˆ›å»ºäº§å“è¯·æ±‚ä¸åŒ…å« idï¼Œç”± Supabase è‡ªåŠ¨ç”Ÿæˆ
    """
    code: str
    name: str
    price: Optional[float] = None   # ä»·æ ¼é€‰å¡«ï¼Œå¯ä¸ºç©º
    category: Optional[str] = None
    image_url: Optional[str] = None


@router.get("", response_model=List[Product])
async def get_products():
    """è¯»å–æ‰€æœ‰äº§å“ï¼Œæ— é¡»é‰´æƒï¼Œä¾›å‰ç«¯ä¸å¨æˆ¿è¯»å–"""
    response = supabase.table("products").select("*").execute()
    return response.data


def bump_menu_version():
    """è¾…åŠ©å‡½æ•°ï¼šå˜åŠ¨æ—¶æ›´æ–°ç³»ç»Ÿé…ç½®çš„èœå•ç‰ˆæœ¬å·"""
    try:
        supabase.table("system_config").upsert({
            "key": "menu_version",
            "value": {"version": str(uuid.uuid4())}
        }).execute()
    except Exception as e:
        print("Failed to bump menu version:", e)


@router.post("", response_model=Product)
async def create_product(product: ProductCreate):
    """
    åˆ›å»ºæ–°èœè°±äº§å“ã€‚
    NOTE: å·²ç§»é™¤ require_admin é‰´æƒä¾èµ–ï¼Œç”±å‰ç«¯ ProtectedRoute ä¿æŠ¤ã€‚
    Supabase ä½¿ç”¨ service_role key å†™å…¥ï¼Œä¸å— RLS å½±å“ã€‚
    """
    data = {k: v for k, v in product.dict().items() if v is not None}
    response = supabase.table("products").insert(data).execute()
    bump_menu_version()
    return response.data[0]


@router.put("/{product_id}", response_model=Product)
async def update_product(product_id: str, product_update: dict):
    """æ›´æ–°äº§å“ä¿¡æ¯ï¼Œå·²ç§»é™¤å¼ºåˆ¶é‰´æƒ"""
    response = supabase.table("products").update(product_update).eq("id", product_id).execute()
    bump_menu_version()
    return response.data[0]


@router.post("/upload")
async def upload_product_image(file: UploadFile = File(...)):
    """
    Backend endpoint to handle image uploads and bypass RLS.
    """
    contents = await file.read()
    file_ext = file.filename.split('.')[-1] if file.filename and '.' in file.filename else 'jpg'
    path = f"products/{uuid.uuid4()}.{file_ext}"
    
    # Upload to Supabase Storage using service_role
    supabase.storage.from_("delivery-photos").upload(
        path=path,
        file=contents,
        file_options={"content-type": file.content_type, "upsert": "true"}
    )
    
    # Get public URL
    public_url = supabase.storage.from_("delivery-photos").get_public_url(path)
    return {"url": public_url}


@router.delete("/{product_id}")
async def delete_product(product_id: str):
    """ä¸‹æ¶äº§å“ï¼Œå·²ç§»é™¤å¼ºåˆ¶é‰´æƒ"""
    supabase.table("products").delete().eq("id", product_id).execute()
    bump_menu_version()
    return {"message": "Product deleted"}


--- FILE: backend\routers\super_admin.py ---
"""
Super Admin è·¯ç”±æ¨¡å—
æä¾›è¶…çº§ç®¡ç†å‘˜ä¸“å±çš„ API ç«¯ç‚¹ï¼šç”¨æˆ·ç®¡ç†ã€ç³»ç»Ÿé…ç½®ã€å®¡è®¡æ—¥å¿—ã€ç»Ÿè®¡æ€»è§ˆ
æ‰€æœ‰è·¯ç”±å‡å— require_super_admin æƒé™å®ˆå«ä¿æŠ¤
"""
import logging
from typing import Optional
from fastapi import APIRouter, HTTPException, Depends, Query
from database import supabase
from models import (
    UserRole, UserUpdate, SystemConfig, SystemConfigUpdate,
    AuditLog, StatsOverview, Order, User,
)
from middleware.auth import require_super_admin

logger = logging.getLogger(__name__)

router = APIRouter(
    prefix="/super-admin",
    tags=["super-admin"],
    dependencies=[Depends(require_super_admin)],
)


# â”€â”€ è¾…åŠ©å‡½æ•°ï¼šè®°å½•å®¡è®¡æ—¥å¿— â”€â”€

async def _log_audit(actor: dict, action: str, target: str, detail: Optional[dict] = None) -> None:
    """
    å°† Super Admin çš„æ“ä½œå†™å…¥å®¡è®¡æ—¥å¿—è¡¨
    """
    try:
        supabase.table("audit_logs").insert({
            "actor_id": actor.get("id"),
            "actor_role": actor.get("role"),
            "action": action,
            "target": target,
            "detail": detail or {},
        }).execute()
    except Exception as e:
        # NOTE: å®¡è®¡æ—¥å¿—å†™å…¥å¤±è´¥ä¸åº”é˜»æ–­ä¸»æµç¨‹
        logger.error("Failed to write audit log: %s", str(e))


# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
# 1. ç»Ÿè®¡æ€»è§ˆ
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

@router.get("/stats", response_model=StatsOverview)
async def get_stats_overview(
    current_user: dict = Depends(require_super_admin),
):
    """
    è·å–å…¨å±€ç»Ÿè®¡æ•°æ®ï¼šè®¢å•æ€»æ•°ã€æ€»è¥æ”¶ã€ç”¨æˆ·æ€»æ•°ã€å„çŠ¶æ€è®¢å•å æ¯”
    """
    # æ‹‰å–æ‰€æœ‰è®¢å•
    orders_resp = supabase.table("orders").select("*").execute()
    orders = orders_resp.data or []

    # æ‹‰å–æ‰€æœ‰ç”¨æˆ·
    users_resp = supabase.table("users").select("id").execute()
    users = users_resp.data or []

    # æŒ‰çŠ¶æ€åˆ†ç»„ç»Ÿè®¡
    status_counts: dict[str, int] = {}
    total_revenue = 0.0
    for order in orders:
        status = order.get("status", "unknown")
        status_counts[status] = status_counts.get(status, 0) + 1
        total_revenue += float(order.get("amount", 0))

    # æœ€è¿‘ 5 æ¡è®¢å•
    recent = sorted(orders, key=lambda o: o.get("created_at", ""), reverse=True)[:5]

    return StatsOverview(
        total_orders=len(orders),
        total_revenue=total_revenue,
        total_users=len(users),
        orders_by_status=status_counts,
        recent_orders=recent,
    )


# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
# 2. ç”¨æˆ·ç®¡ç†
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

@router.get("/users")
async def list_all_users(
    current_user: dict = Depends(require_super_admin),
):
    """
    è·å–æ‰€æœ‰ç”¨æˆ·åˆ—è¡¨
    """
    response = supabase.table("users").select("*").execute()
    return response.data or []


@router.patch("/users/{user_id}")
async def update_user(
    user_id: str,
    update: UserUpdate,
    current_user: dict = Depends(require_super_admin),
):
    """
    ä¿®æ”¹ç”¨æˆ·è§’è‰²æˆ–ç¦ç”¨çŠ¶æ€
    """
    # æ„å»ºæ›´æ–°æ•°æ®ï¼ŒåªåŒ…å«é None å­—æ®µ
    update_data = {k: v for k, v in update.model_dump().items() if v is not None}
    if not update_data:
        raise HTTPException(status_code=400, detail="No fields to update")

    # NOTE: å¦‚æœ role æ˜¯æšä¸¾ç±»å‹ï¼Œéœ€è¦è½¬æ¢ä¸ºå­—ç¬¦ä¸²å€¼
    if "role" in update_data:
        update_data["role"] = update_data["role"].value if hasattr(update_data["role"], "value") else update_data["role"]

    response = supabase.table("users").update(update_data).eq("id", user_id).execute()
    if not response.data:
        raise HTTPException(status_code=404, detail="User not found")

    # è®°å½•å®¡è®¡æ—¥å¿—
    await _log_audit(
        actor=current_user,
        action="update_user",
        target=user_id,
        detail=update_data,
    )

    return response.data[0]


@router.delete("/users/{user_id}")
async def delete_user(
    user_id: str,
    current_user: dict = Depends(require_super_admin),
):
    """
    åˆ é™¤ç”¨æˆ·è´¦å·
    """
    # é˜²æ­¢åˆ é™¤è‡ªèº«
    if user_id == current_user.get("id"):
        raise HTTPException(status_code=400, detail="Cannot delete your own account")

    response = supabase.table("users").delete().eq("id", user_id).execute()

    await _log_audit(
        actor=current_user,
        action="delete_user",
        target=user_id,
    )

    return {"message": "User deleted successfully"}


# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
# 3. ç³»ç»Ÿé…ç½®
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

@router.get("/config")
async def get_all_config(
    current_user: dict = Depends(require_super_admin),
):
    """
    è¯»å–æ‰€æœ‰ç³»ç»Ÿé…ç½®é¡¹
    """
    response = supabase.table("system_config").select("*").execute()
    return response.data or []


@router.put("/config/{key}")
async def upsert_config(
    key: str,
    config: SystemConfigUpdate,
    current_user: dict = Depends(require_super_admin),
):
    """
    åˆ›å»ºæˆ–æ›´æ–°å•ä¸ªç³»ç»Ÿé…ç½®é¡¹ï¼ˆupsert è¯­ä¹‰ï¼‰
    """
    data = {
        "key": key,
        "value": config.value,
        "updated_by": current_user.get("id"),
    }
    response = supabase.table("system_config").upsert(data).execute()

    await _log_audit(
        actor=current_user,
        action="update_config",
        target=key,
        detail=config.value,
    )

    if response.data:
        return response.data[0]
    return data


# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
# 4. å®¡è®¡æ—¥å¿—
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

@router.get("/audit-logs")
async def get_audit_logs(
    page: int = Query(1, ge=1, description="é¡µç "),
    page_size: int = Query(20, ge=1, le=100, description="æ¯é¡µæ¡æ•°"),
    current_user: dict = Depends(require_super_admin),
):
    """
    åˆ†é¡µæŸ¥è¯¢å®¡è®¡æ—¥å¿—ï¼ŒæŒ‰æ—¶é—´å€’åº
    """
    offset = (page - 1) * page_size

    response = (
        supabase.table("audit_logs")
        .select("*")
        .order("created_at", desc=True)
        .range(offset, offset + page_size - 1)
        .execute()
    )

    # è·å–æ€»æ•°ç”¨äºåˆ†é¡µ
    count_resp = supabase.table("audit_logs").select("id", count="exact").execute()
    total = count_resp.count if hasattr(count_resp, "count") and count_resp.count else 0

    return {
        "data": response.data or [],
        "page": page,
        "page_size": page_size,
        "total": total,
    }


# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
# 5. å…¨å±€è®¢å•ç›‘æ§ä¸å®¡æ‰¹
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

@router.get("/orders")
async def get_all_orders(
    status: Optional[str] = Query(None, description="è®¢å•çŠ¶æ€ç­›é€‰"),
    current_user: dict = Depends(require_super_admin),
):
    """
    è·å–å…¨å±€è®¢å•åˆ—è¡¨ï¼Œæ”¯æŒæŒ‰çŠ¶æ€ç­›é€‰
    """
    query = supabase.table("orders").select("*").order("created_at", desc=True)
    if status:
        query = query.eq("status", status)
        
    response = query.execute()
    return response.data or []


@router.patch("/orders/{order_id}/approve")
async def approve_order(
    order_id: str,
    current_user: dict = Depends(require_super_admin),
):
    """
    å®¡æ‰¹è®¢å•ï¼šå°†çŠ¶æ€ä» pending ä¿®æ”¹ä¸º preparing
    """
    # éªŒè¯è®¢å•å½“å‰çŠ¶æ€
    order_resp = supabase.table("orders").select("*").eq("id", order_id).execute()
    if not order_resp.data:
        raise HTTPException(status_code=404, detail="Order not found")
        
    order = order_resp.data[0]
    if order.get("status") != "pending":
        raise HTTPException(status_code=400, detail=f"Cannot approve order in {order.get('status')} status")
        
    # æ›´æ–°çŠ¶æ€ä¸º preparing
    update_data = {"status": "preparing"}
    response = supabase.table("orders").update(update_data).eq("id", order_id).execute()
    
    # è®°å½•å®¡è®¡æ—¥å¿—
    await _log_audit(
        actor=current_user,
        action="approve_order",
        target=order_id,
        detail={"old_status": "pending", "new_status": "preparing"},
    )
    
    return response.data[0]


--- FILE: backend\routers\users.py ---
from fastapi import APIRouter, HTTPException
from typing import List
from database import supabase
from models import User, UserRole

router = APIRouter(
    prefix="/users",
    tags=["users"]
)

@router.get("/", response_model=List[User])
async def get_users():
    response = supabase.table("users").select("*").execute()
    return response.data

@router.get("/{user_id}", response_model=User)
async def get_user(user_id: str):
    response = supabase.table("users").select("*").eq("id", user_id).execute()
    if not response.data:
        raise HTTPException(status_code=404, detail="User not found")
    return response.data[0]

# Simple login simulation by checking email/role exists
@router.post("/login")
async def login(email: str, role: UserRole):
    # In a real app, use Supabase Auth (GoTrue).
    # Here we just check if a user with this email and role exists in our 'users' table
    response = supabase.table("users").select("*").eq("email", email).eq("role", role).execute()
    if not response.data:
        raise HTTPException(status_code=401, detail="Invalid credentials")
    return response.data[0]


--- FILE: backend\routers\walkie_talkie.py ---
from fastapi import APIRouter, WebSocket, WebSocketDisconnect
import logging
from typing import List, Dict

logger = logging.getLogger(__name__)

router = APIRouter(
    prefix="/ws",
    tags=["websocket-walkie-talkie"]
)

class ConnectionManager:
    def __init__(self):
        # è®°å½•æ‰€æœ‰æ´»è·ƒçš„è¿æ¥
        self.active_connections: List[WebSocket] = []

    async def connect(self, websocket: WebSocket):
        await websocket.accept()
        self.active_connections.append(websocket)
        logger.info(f"New Walkie-Talkie Connection, Total: {len(self.active_connections)}")

    def disconnect(self, websocket: WebSocket):
        if websocket in self.active_connections:
            self.active_connections.remove(websocket)
            logger.info(f"Walkie-Talkie Disconnected, Total: {len(self.active_connections)}")

    async def broadcast_audio(self, sender: WebSocket, data: bytes):
        """
        å‘é™¤äº†å‘é€è€…ä»¥å¤–çš„æ‰€æœ‰è¿æ¥å¹¿æ’­éŸ³é¢‘æ•°æ®
        """
        disconnected = []
        for connection in self.active_connections:
            if connection != sender:
                try:
                    await connection.send_bytes(data)
                except Exception as e:
                    logger.error(f"Failed to send audio data: {e}")
                    disconnected.append(connection)
        
        # æ¸…ç†å¼‚å¸¸æ–­å¼€çš„è¿æ¥
        for dead_conn in disconnected:
            self.disconnect(dead_conn)

manager = ConnectionManager()

@router.websocket("/walkie-talkie")
async def walkie_talkie_endpoint(websocket: WebSocket):
    """
    WebSocket å¯¹è®²æœºé¢‘é“ï¼š
    æ¥æ”¶äºŒè¿›åˆ¶éŸ³é¢‘æµ (PCM/WebM ç­‰)ï¼Œå¹¶åŸæ ·å¹¿æ’­ç»™è®¢é˜…äº†é¢‘é“çš„å…¶ä»–æ‰€æœ‰äººã€‚
    """
    await manager.connect(websocket)
    try:
        while True:
            # æ¥æ”¶äºŒè¿›åˆ¶éŸ³é¢‘å—
            data = await websocket.receive_bytes()
            # å¹¿æ’­ç»™å…¶ä»–åœ¨çº¿ç»ˆç«¯
            await manager.broadcast_audio(websocket, data)
    except WebSocketDisconnect:
        manager.disconnect(websocket)
    except Exception as e:
        logger.error(f"Walkie-talkie unexpected error: {e}")
        manager.disconnect(websocket)


--- FILE: backend\routers\__init__.py ---


